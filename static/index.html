<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>å¤§æ–‡ä»¶åˆ†ç‰‡ä¸Šä¼ </title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .upload-option { margin: 10px 0; }
    .upload-option label { margin-right: 10px; }
    .config-section { 
      border: 1px solid #ddd; 
      padding: 15px; 
      margin: 15px 0; 
      border-radius: 5px; 
      background-color: #f9f9f9; 
    }
    .config-section h3 { margin-top: 0; }
    .config-item { margin: 10px 0; }
    .config-item label { display: inline-block; width: 120px; }
    .config-item input, .config-item select { 
      width: 200px; 
      padding: 5px; 
      border: 1px solid #ccc; 
      border-radius: 3px; 
    }
    .progress-container { margin: 20px 0; }
    .progress-bar { 
      width: 100%; 
      height: 20px; 
      background-color: #f0f0f0; 
      border-radius: 10px; 
      overflow: hidden; 
    }
    .progress-fill { 
      height: 100%; 
      background-color: #4CAF50; 
      transition: width 0.3s ease; 
    }
    .file-list { 
      max-height: 200px; 
      overflow-y: auto; 
      border: 1px solid #ddd; 
      padding: 10px; 
      margin: 10px 0; 
    }
    .file-item { 
      padding: 5px; 
      border-bottom: 1px solid #eee; 
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .file-item:last-child { 
      border-bottom: none; 
    }
    .file-status {
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
    }
    .status-pending { background-color: #ffeaa7; color: #2d3436; }
    .status-uploading { background-color: #74b9ff; color: white; }
    .status-completed { background-color: #00b894; color: white; }
    .status-error { background-color: #e17055; color: white; }
    .error { color: red; }
    .success { color: green; }
    .task-manager {
      border: 1px solid #ddd;
      padding: 15px;
      margin: 15px 0;
      border-radius: 5px;
      background-color: #f0f8ff;
    }
    .task-item {
      padding: 10px;
      border: 1px solid #ccc;
      margin: 5px 0;
      border-radius: 3px;
      background-color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .task-actions button {
      margin-left: 5px;
      padding: 5px 10px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .btn-resume { background-color: #4CAF50; color: white; }
    .btn-delete { background-color: #f44336; color: white; }
    .concurrent-status {
      margin: 10px 0;
      padding: 10px;
      background-color: #e8f5e8;
      border-radius: 5px;
      border-left: 4px solid #4CAF50;
    }
  </style>
</head>
<body>
  <h2>å¤§æ–‡ä»¶/æ–‡ä»¶å¤¹ä¸Šä¼  - é«˜çº§ç‰ˆ</h2>
  
  <div class="config-section">
    <h3>âš™ï¸ ä¸Šä¼ é…ç½®</h3>
    <div class="config-item">
      <label>åˆ†ç‰‡å¤§å°:</label>
      <select id="chunkSizeSelect" onchange="updateChunkSize()">
        <option value="5">5MB (ç½‘ç»œè¾ƒæ…¢)</option>
        <option value="10" selected>10MB (é»˜è®¤)</option>
        <option value="20">20MB (ç½‘ç»œè‰¯å¥½)</option>
        <option value="50">50MB (é«˜é€Ÿç½‘ç»œ)</option>
        <option value="100">100MB (åƒå…†ç½‘ç»œ)</option>
      </select>
    </div>
    <div class="config-item">
      <label>å¹¶å‘æ•°é‡:</label>
      <select id="concurrentSelect">
        <option value="1">1 (å•çº¿ç¨‹)</option>
        <option value="2">2 (æ¨è)</option>
        <option value="3" selected>3 (é»˜è®¤)</option>
        <option value="4">4 (é«˜æ€§èƒ½)</option>
        <option value="5">5 (æœ€å¤§)</option>
      </select>
    </div>
    <div class="config-item">
      <label>ä»»åŠ¡åç§°:</label>
      <input type="text" id="taskName" placeholder="è¾“å…¥ä»»åŠ¡åç§° (å¯é€‰)">
    </div>
  </div>
  
  <div class="upload-option">
    <label>
      <input type="radio" name="uploadType" value="file" checked onchange="toggleUploadType()">
      å•æ–‡ä»¶ä¸Šä¼ 
    </label>
    <label>
      <input type="radio" name="uploadType" value="folder" onchange="toggleUploadType()">
      æ–‡ä»¶å¤¹ä¸Šä¼ 
    </label>
  </div>
  
  <input type="file" id="fileInput" style="display: block;">
  <input type="file" id="folderInput" webkitdirectory style="display: none;">
  
  <div id="fileList" class="file-list" style="display: none;"></div>
  
  <div class="concurrent-status" id="concurrentStatus" style="display: none;">
    <div>å¹¶å‘ä¸Šä¼ çŠ¶æ€: <span id="concurrentInfo">å‡†å¤‡ä¸­...</span></div>
    <div>æ´»è·ƒä»»åŠ¡: <span id="activeTasks">0</span> / å®Œæˆä»»åŠ¡: <span id="completedTasks">0</span> / å¤±è´¥ä»»åŠ¡: <span id="failedTasks">0</span></div>
  </div>
  
  <div class="progress-container" style="display: none;" id="progressContainer">
    <div>æ€»è¿›åº¦: <span id="progressText">0%</span></div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
    </div>
    <div>é¢„è®¡å‰©ä½™æ—¶é—´: <span id="remainingTime">è®¡ç®—ä¸­...</span></div>
  </div>
  
  <button onclick="startUpload()" id="uploadBtn">å¼€å§‹ä¸Šä¼ </button>
  <button onclick="pauseUpload()" id="pauseBtn" style="display: none;">æš‚åœä¸Šä¼ </button>
  <button onclick="cancelUpload()" id="cancelBtn" style="display: none;">å–æ¶ˆä¸Šä¼ </button>
  
  <div class="task-manager">
    <h3>ğŸ“‹ ä»»åŠ¡ç®¡ç†</h3>
    <button onclick="refreshTasks()">åˆ·æ–°ä»»åŠ¡åˆ—è¡¨</button>
    <button onclick="clearCompletedTasks()">æ¸…ç†å·²å®Œæˆä»»åŠ¡</button>
    <div id="taskList"></div>
  </div>
  
  <pre id="log"></pre>

  <script>
    let CHUNK_SIZE = 10 * 1024 * 1024; // é»˜è®¤10MB
    let uploadQueue = [];
    let isUploading = false;
    let isPaused = false;
    let cancelFlag = false;
    let concurrentLimit = 3;
    let activeTasks = 0;
    let completedTasks = 0;
    let failedTasks = 0;
    let startTime = 0;
    let currentTaskId = null;

    function log(msg) {
      const logElement = document.getElementById("log");
      const timestamp = new Date().toLocaleTimeString();
      logElement.textContent += `[${timestamp}] ${msg}\n`;
      logElement.scrollTop = logElement.scrollHeight;
    }

    function updateChunkSize() {
      const sizeInMB = parseInt(document.getElementById("chunkSizeSelect").value);
      CHUNK_SIZE = sizeInMB * 1024 * 1024;
      log(`ğŸ”§ åˆ†ç‰‡å¤§å°è°ƒæ•´ä¸º: ${sizeInMB}MB`);
    }

    function toggleUploadType() {
      const uploadType = document.querySelector('input[name="uploadType"]:checked').value;
      const fileInput = document.getElementById("fileInput");
      const folderInput = document.getElementById("folderInput");
      const fileList = document.getElementById("fileList");
      
      if (uploadType === "file") {
        fileInput.style.display = "block";
        folderInput.style.display = "none";
        fileList.style.display = "none";
      } else {
        fileInput.style.display = "none";
        folderInput.style.display = "block";
        fileList.style.display = "block";
      }
      
      uploadQueue = [];
      updateFileList();
      updateProgress(0, 0);
    }

    function updateFileList() {
      const fileList = document.getElementById("fileList");
      if (uploadQueue.length === 0) {
        fileList.innerHTML = "<div>æš‚æ— æ–‡ä»¶</div>";
        return;
      }
      
      let html = `<div><strong>å…± ${uploadQueue.length} ä¸ªæ–‡ä»¶ï¼Œæ€»å¤§å°: ${formatFileSize(uploadQueue.reduce((sum, item) => sum + item.file.size, 0))}</strong></div>`;
      uploadQueue.forEach((item, index) => {
        const statusClass = `status-${item.status}`;
        const statusText = {
          'pending': 'ç­‰å¾…',
          'uploading': 'ä¸Šä¼ ä¸­',
          'completed': 'å®Œæˆ',
          'error': 'å¤±è´¥'
        }[item.status] || 'æœªçŸ¥';
        
        html += `<div class="file-item">
          <span>${item.file.webkitRelativePath || item.file.name} (${formatFileSize(item.file.size)})</span>
          <span class="file-status ${statusClass}">${statusText}</span>
        </div>`;
      });
      fileList.innerHTML = html;
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function updateProgress(current, total) {
      const progressContainer = document.getElementById("progressContainer");
      const progressText = document.getElementById("progressText");
      const progressFill = document.getElementById("progressFill");
      const remainingTimeSpan = document.getElementById("remainingTime");
      
      if (total === 0) {
        progressContainer.style.display = "none";
        return;
      }
      
      progressContainer.style.display = "block";
      const percentage = Math.round((current / total) * 100);
      progressText.textContent = `${percentage}% (${current}/${total})`;
      progressFill.style.width = `${percentage}%`;
      
      // è®¡ç®—å‰©ä½™æ—¶é—´
      if (current > 0 && startTime > 0) {
        const elapsed = (Date.now() - startTime) / 1000;
        const rate = current / elapsed;
        const remaining = (total - current) / rate;
        remainingTimeSpan.textContent = formatTime(remaining);
      } else {
        remainingTimeSpan.textContent = "è®¡ç®—ä¸­...";
      }
    }

    function updateConcurrentStatus() {
      const concurrentStatus = document.getElementById("concurrentStatus");
      const concurrentInfo = document.getElementById("concurrentInfo");
      const activeTasksSpan = document.getElementById("activeTasks");
      const completedTasksSpan = document.getElementById("completedTasks");
      const failedTasksSpan = document.getElementById("failedTasks");
      
      if (isUploading) {
        concurrentStatus.style.display = "block";
        concurrentInfo.textContent = `å¹¶å‘é™åˆ¶: ${concurrentLimit}`;
        activeTasksSpan.textContent = activeTasks;
        completedTasksSpan.textContent = completedTasks;
        failedTasksSpan.textContent = failedTasks;
      } else {
        concurrentStatus.style.display = "none";
      }
    }

    function formatTime(seconds) {
      if (!seconds || seconds === Infinity) return "æœªçŸ¥";
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // ç›‘å¬æ–‡ä»¶é€‰æ‹©
    document.getElementById("fileInput").addEventListener("change", function(e) {
      uploadQueue = [];
      if (e.target.files.length > 0) {
        uploadQueue.push({
          file: e.target.files[0],
          status: 'pending'
        });
      }
      updateFileList();
    });

    document.getElementById("folderInput").addEventListener("change", function(e) {
      uploadQueue = [];
      for (let file of e.target.files) {
        uploadQueue.push({
          file: file,
          status: 'pending'
        });
      }
      updateFileList();
      log(`é€‰æ‹©äº† ${uploadQueue.length} ä¸ªæ–‡ä»¶ï¼Œæ€»å¤§å°: ${formatFileSize(uploadQueue.reduce((sum, item) => sum + item.file.size, 0))}`);
      
      // æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„ä»»åŠ¡å¯ä»¥æ¢å¤
      checkForResumableTask();
    });

    function generateTaskId(files) {
      // åŸºäºæ–‡ä»¶åˆ—è¡¨ç”Ÿæˆå”¯ä¸€çš„ä»»åŠ¡ID
      const fileSignature = files.map(item => 
        `${item.file.webkitRelativePath || item.file.name}-${item.file.size}`
      ).sort().join('|');
      
      // ä½¿ç”¨å®‰å…¨çš„ç¼–ç æ–¹å¼å¤„ç†ä»»ä½•å­—ç¬¦
      return 'task_' + encodeURIComponent(fileSignature)
        .replace(/%/g, '')
        .substring(0, 16);
    }

    function saveTaskProgress() {
      if (!currentTaskId) return;
      
      const taskData = {
        id: currentTaskId,
        name: document.getElementById("taskName").value || `ä»»åŠ¡_${new Date().toLocaleString()}`,
        files: uploadQueue.map(item => ({
          name: item.file.name,
          size: item.file.size,
          relativePath: item.file.webkitRelativePath || "",
          status: item.status
        })),
        config: {
          chunkSize: CHUNK_SIZE,
          concurrentLimit: concurrentLimit
        },
        progress: {
          completed: completedTasks,
          failed: failedTasks,
          total: uploadQueue.length
        },
        timestamp: Date.now()
      };
      
      const savedTasks = JSON.parse(localStorage.getItem('uploadTasks') || '{}');
      savedTasks[currentTaskId] = taskData;
      localStorage.setItem('uploadTasks', JSON.stringify(savedTasks));
    }

    function checkForResumableTask() {
      if (uploadQueue.length === 0) return;
      
      const taskId = generateTaskId(uploadQueue);
      const savedTasks = JSON.parse(localStorage.getItem('uploadTasks') || '{}');
      
      if (savedTasks[taskId] && savedTasks[taskId].progress.completed < savedTasks[taskId].progress.total) {
        if (confirm(`æ£€æµ‹åˆ°æœªå®Œæˆçš„ä»»åŠ¡ "${savedTasks[taskId].name}"ï¼Œæ˜¯å¦ç»§ç»­ä¸Šä¼ ï¼Ÿ`)) {
          loadTask(taskId);
        }
      }
    }

    function loadTask(taskId) {
      const savedTasks = JSON.parse(localStorage.getItem('uploadTasks') || '{}');
      const taskData = savedTasks[taskId];
      
      if (!taskData) return;
      
      currentTaskId = taskId;
      document.getElementById("taskName").value = taskData.name;
      
      // æ¢å¤é…ç½®
      CHUNK_SIZE = taskData.config.chunkSize;
      concurrentLimit = taskData.config.concurrentLimit;
      
      // æ›´æ–°UI
      const chunkSizeMB = CHUNK_SIZE / (1024 * 1024);
      document.getElementById("chunkSizeSelect").value = chunkSizeMB;
      document.getElementById("concurrentSelect").value = concurrentLimit;
      
      log(`ğŸ“‚ æ¢å¤ä»»åŠ¡: ${taskData.name}`);
      log(`âš™ï¸ é…ç½® - åˆ†ç‰‡: ${chunkSizeMB}MB, å¹¶å‘: ${concurrentLimit}`);
      
      refreshTasks();
    }

    function pauseUpload() {
      isPaused = true;
      log("â¸ï¸ ä¸Šä¼ å·²æš‚åœ");
      document.getElementById("pauseBtn").style.display = "none";
      document.getElementById("uploadBtn").style.display = "inline-block";
      document.getElementById("uploadBtn").textContent = "ç»§ç»­ä¸Šä¼ ";
      saveTaskProgress();
    }

    function cancelUpload() {
      cancelFlag = true;
      isPaused = false;
      log("âŒ ç”¨æˆ·å–æ¶ˆä¸Šä¼ ");
      saveTaskProgress();
    }

    async function startUpload() {
      if (uploadQueue.length === 0) {
        return alert("è¯·é€‰æ‹©æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹");
      }
      
      if (isUploading && !isPaused) {
        return alert("æ­£åœ¨ä¸Šä¼ ä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆ");
      }
      
      // è·å–é…ç½®
      concurrentLimit = parseInt(document.getElementById("concurrentSelect").value);
      
      // ç”Ÿæˆæˆ–æ¢å¤ä»»åŠ¡ID
      if (!currentTaskId) {
        currentTaskId = generateTaskId(uploadQueue);
      }
      
      isUploading = true;
      isPaused = false;
      cancelFlag = false;
      startTime = Date.now();
      
      // é‡ç½®è®¡æ•°å™¨
      activeTasks = 0;
      if (document.getElementById("uploadBtn").textContent !== "ç»§ç»­ä¸Šä¼ ") {
        completedTasks = 0;
        failedTasks = 0;
      }
      
      document.getElementById("uploadBtn").style.display = "none";
      document.getElementById("pauseBtn").style.display = "inline-block";
      document.getElementById("cancelBtn").style.display = "inline-block";
      
      log(`ğŸš€ å¼€å§‹${document.getElementById("uploadBtn").textContent === "ç»§ç»­ä¸Šä¼ " ? "ç»§ç»­" : ""}æ‰¹é‡ä¸Šä¼ ï¼Œå…± ${uploadQueue.length} ä¸ªæ–‡ä»¶`);
      log(`âš™ï¸ é…ç½® - åˆ†ç‰‡å¤§å°: ${CHUNK_SIZE / (1024 * 1024)}MB, å¹¶å‘æ•°é‡: ${concurrentLimit}`);
      
      await concurrentUpload();
      
      updateProgress(uploadQueue.length, uploadQueue.length);
      updateConcurrentStatus();
      log(`ğŸ“Š ä¸Šä¼ å®Œæˆ: ${completedTasks}/${uploadQueue.length} ä¸ªæ–‡ä»¶æˆåŠŸ`);
      
      isUploading = false;
      document.getElementById("uploadBtn").style.display = "inline-block";
      document.getElementById("uploadBtn").textContent = "å¼€å§‹ä¸Šä¼ ";
      document.getElementById("pauseBtn").style.display = "none";
      document.getElementById("cancelBtn").style.display = "none";
      
      saveTaskProgress();
      refreshTasks();
    }

    async function concurrentUpload() {
      const pendingFiles = uploadQueue.filter(item => item.status === 'pending');
      let index = 0;
      
      const workers = [];
      
      // åˆ›å»ºå¹¶å‘å·¥ä½œçº¿ç¨‹
      for (let i = 0; i < concurrentLimit; i++) {
        workers.push(uploadWorker());
      }
      
      async function uploadWorker() {
        while (index < pendingFiles.length && !cancelFlag && !isPaused) {
          const fileIndex = index++;
          const item = pendingFiles[fileIndex];
          
          if (!item || item.status !== 'pending') continue;
          
          activeTasks++;
          item.status = 'uploading';
          updateFileList();
          updateConcurrentStatus();
          
          try {
            await uploadSingleFile(item.file);
            item.status = 'completed';
            completedTasks++;
            log(`âœ… å®Œæˆ: ${item.file.webkitRelativePath || item.file.name}`);
          } catch (error) {
            item.status = 'error';
            failedTasks++;
            log(`âŒ å¤±è´¥: ${item.file.webkitRelativePath || item.file.name} - ${error}`);
          }
          
          activeTasks--;
          updateFileList();
          updateProgress(completedTasks + failedTasks, uploadQueue.length);
          updateConcurrentStatus();
          
          // å®šæœŸä¿å­˜è¿›åº¦
          if ((completedTasks + failedTasks) % 5 === 0) {
            saveTaskProgress();
          }
        }
      }
      
      // ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ
      await Promise.all(workers);
    }

    async function uploadSingleFile(file) {
      const fileId = `${file.webkitRelativePath || file.name}-${file.size}-${Date.now()}`;
      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

      // è·å–å·²ä¸Šä¼ åˆ†ç‰‡ç´¢å¼•
      let uploadedChunks = [];
      try {
        const res = await fetch(`/go-uploader/upload_status?file_id=${encodeURIComponent(fileId)}`);
        const data = await res.json();
        uploadedChunks = data.uploaded_chunks || [];
      } catch (err) {
        // å¿½ç•¥çŠ¶æ€æŸ¥è¯¢é”™è¯¯
      }

      // ä¸Šä¼ åˆ†ç‰‡
      for (let i = 0; i < totalChunks; i++) {
        if (cancelFlag || isPaused) throw new Error("ä¸Šä¼ è¢«ä¸­æ–­");
        
        if (uploadedChunks.includes(i)) {
          continue;
        }

        const start = i * CHUNK_SIZE;
        const end = Math.min(file.size, start + CHUNK_SIZE);
        const chunk = file.slice(start, end);

        const form = new FormData();
        form.append("file_id", fileId);
        form.append("chunk_index", i);
        form.append("chunk", chunk);
        form.append("relative_path", file.webkitRelativePath || file.name);

        const response = await fetch("/go-uploader/upload_chunk", { method: "POST", body: form });
        if (!response.ok) {
          throw new Error(`åˆ†ç‰‡ ${i} ä¸Šä¼ å¤±è´¥: ${response.status}`);
        }
      }

      // åˆå¹¶æ–‡ä»¶
      const mergeForm = new FormData();
      mergeForm.append("file_id", fileId);
      mergeForm.append("total_chunks", totalChunks);
      mergeForm.append("filename", file.name);
      mergeForm.append("relative_path", file.webkitRelativePath || file.name);

      const mergeRes = await fetch("/go-uploader/merge_chunks", { method: "POST", body: mergeForm });
      if (!mergeRes.ok) {
        throw new Error(`åˆå¹¶å¤±è´¥: ${mergeRes.status}`);
      }
      
      const result = await mergeRes.json();
      return result;
    }

    function refreshTasks() {
      const savedTasks = JSON.parse(localStorage.getItem('uploadTasks') || '{}');
      const taskList = document.getElementById("taskList");
      
      if (Object.keys(savedTasks).length === 0) {
        taskList.innerHTML = "<div>æš‚æ— ä¿å­˜çš„ä»»åŠ¡</div>";
        return;
      }
      
      let html = "";
      Object.values(savedTasks).forEach(task => {
        const isCompleted = task.progress.completed === task.progress.total;
        const statusText = isCompleted ? "å·²å®Œæˆ" : `è¿›è¡Œä¸­ (${task.progress.completed}/${task.progress.total})`;
        const timeText = new Date(task.timestamp).toLocaleString();
        
        html += `<div class="task-item">
          <div>
            <strong>${task.name}</strong><br>
            <small>${task.files.length} ä¸ªæ–‡ä»¶ - ${statusText} - ${timeText}</small>
          </div>
          <div class="task-actions">
            ${!isCompleted ? `<button class="btn-resume" onclick="resumeTask('${task.id}')">ç»§ç»­</button>` : ''}
            <button class="btn-delete" onclick="deleteTask('${task.id}')">åˆ é™¤</button>
          </div>
        </div>`;
      });
      
      taskList.innerHTML = html;
    }

    function resumeTask(taskId) {
      if (isUploading) {
        alert("è¯·å…ˆåœæ­¢å½“å‰ä¸Šä¼ ä»»åŠ¡");
        return;
      }
      
      const savedTasks = JSON.parse(localStorage.getItem('uploadTasks') || '{}');
      const task = savedTasks[taskId];
      
      if (!task) return;
      
      // éœ€è¦ç”¨æˆ·é‡æ–°é€‰æ‹©æ–‡ä»¶å¤¹æ¥æ¢å¤æ–‡ä»¶å¼•ç”¨
      alert("è¯·é‡æ–°é€‰æ‹©ç›¸åŒçš„æ–‡ä»¶å¤¹æ¥æ¢å¤ä»»åŠ¡");
      currentTaskId = taskId;
      
      // åˆ‡æ¢åˆ°æ–‡ä»¶å¤¹æ¨¡å¼
      document.querySelector('input[name="uploadType"][value="folder"]').checked = true;
      toggleUploadType();
    }

    function deleteTask(taskId) {
      if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ")) {
        const savedTasks = JSON.parse(localStorage.getItem('uploadTasks') || '{}');
        delete savedTasks[taskId];
        localStorage.setItem('uploadTasks', JSON.stringify(savedTasks));
        refreshTasks();
        log(`ğŸ—‘ï¸ å·²åˆ é™¤ä»»åŠ¡: ${taskId}`);
      }
    }

    function clearCompletedTasks() {
      const savedTasks = JSON.parse(localStorage.getItem('uploadTasks') || '{}');
      const filteredTasks = {};
      
      Object.entries(savedTasks).forEach(([id, task]) => {
        if (task.progress.completed < task.progress.total) {
          filteredTasks[id] = task;
        }
      });
      
      localStorage.setItem('uploadTasks', JSON.stringify(filteredTasks));
      refreshTasks();
      log("ğŸ§¹ å·²æ¸…ç†æ‰€æœ‰å·²å®Œæˆçš„ä»»åŠ¡");
    }

    // é¡µé¢åŠ è½½æ—¶åˆ·æ–°ä»»åŠ¡åˆ—è¡¨
    window.addEventListener('load', () => {
      refreshTasks();
      updateConcurrentStatus();
    });

    // é¡µé¢å…³é—­å‰ä¿å­˜è¿›åº¦
    window.addEventListener('beforeunload', () => {
      if (isUploading) {
        saveTaskProgress();
      }
    });
  </script>
</body>
</html>
